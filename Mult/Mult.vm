// -------------------------------------------------------------
// Mult.mul
//   x -> static 0     (supplied by the test)
//   y -> static 1
//   returns x*y on the stack            (also leaves it in local 0)
//
// Locals
//   0  a     running product
//   1  cnt   copy of y (can be + or -)  --> loop drives toward 0
// -------------------------------------------------------------

function Mult.mul 2          // a, cnt

    // a = 0
    push constant 0
    pop  local 0

    // cnt = y
    push static 1
    pop  local 1

    // ------------- while (cnt != 0) --------------------------
    label LOOP_START
        push local 1
        push constant 0
        eq
        if-goto LOOP_END      // done when cnt == 0

        // if cnt < 0  ?
        push local 1
        push constant 0
        lt
        if-goto CNT_NEG

        // -------- cnt > 0 --------  a = a + x ; cnt--
        push local 0
        push static 0
        add
        pop  local 0

        push local 1
        push constant 1
        sub
        pop  local 1
        goto LOOP_START

    // -------- cnt < 0 --------  a = a - x ; cnt++
    label CNT_NEG
        push local 0
        push static 0
        sub
        pop  local 0

        push local 1
        push constant 1
        add
        pop  local 1
        goto LOOP_START

    // ------------- finish -----------------------------------
    label LOOP_END
        push local 0          // return value
        return
